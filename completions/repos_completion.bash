#
# This file was generated by autocomplete-generator https://gitlab.com/philippecaphin/autocomplete-generator
#

# This is the function that will be called when we press TAB.
#
# Its purpose is # to examine the current command line (as represented by the
# array COMP_WORDS) and to determine what the autocomplete should reply through
# the array COMPREPLY.
#
# This function is organized with subroutines who  are responsible for setting
# the 'candidates' variable.
#
# The compgen then filters out the candidates that don't begin with the word we are
# completing. In this case, if '--' is one of the words, we set empty candidates,
# otherwise, we look at the previous word and delegate # to candidate-setting functions
__complete_repos() {

	COMPREPLY=()

	# We use the current word to filter out suggestions
	local cur="${COMP_WORDS[COMP_CWORD]}"
     local candidates=""
     __suggest_repos_candidates

	# Compgen: takes the list of candidates and selects those matching ${cur}.
	# Once COMPREPLY is set, the shell does the rest.
	COMPREPLY=( $(compgen -W "${candidates}" -- ${cur}))

	return 0
}

__suggest_repos_candidates(){
	# We use the current word to decide what to do
	local cur="${COMP_WORDS[COMP_CWORD]}"
	if __repos_dash_dash_in_words ; then
		return
	fi

	option=$(__repos_get_current_option)
	if [[ "$option" != "" ]] ; then
		__suggest_repos_args_for_option ${option}
	else
		# No positional arguments yet
		__suggest_repos_options
	fi
}

__repos_dash_dash_in_words(){
	for ((i=0;i<COMP_CWORD-1;i++)) ; do
		w=${COMP_WORD[$i]}
		if [[ "$w" == "--" ]] ; then
			return 0
		fi
	done
	return 1
}

__repos_get_current_option(){
	# The word before that
	local prev="${COMP_WORDS[COMP_CWORD-1]}"
	if [[ "$prev" == -* ]] ; then
		echo "$prev"
	fi
}

__suggest_repos_options(){
	candidates="-recent -generate-config -j -list-names -list-repos -no-fetch -path -r -get-dir"
}

__suggest_repos_args_for_option(){
	case "$1" in
		-generate-config) __suggest_repos_key_generate_config_values ;;
		-j) __suggest_repos_key_j_values ;;
		-list-names) __suggest_repos_key_list_names_values ;;
		-list-repos) __suggest_repos_key_list_repos_values ;;
		-no-fetch) __suggest_repos_key_no_fetch_values ;;
		-path) __suggest_repos_key_path_values ;;
		-r|-get-dir) __suggest_repos_key_r_values ;;
        -recent) return ;;
	esac
}

__suggest_repos_key_generate_config_values(){
	candidates=""
}

__suggest_repos_key_j_values(){
	candidates=""
}

__suggest_repos_key_list_names_values(){
	candidates=""
}

__suggest_repos_key_list_repos_values(){
	candidates=""
}

__suggest_repos_key_no_fetch_values(){
	candidates=""
}

__suggest_repos_key_path_values(){
	candidates=""
}

__suggest_repos_key_r_values(){
    candidates="$(repos -list-names 2>/dev/null)"
}

complete -o default -F __complete_repos repos

function rcd(){
    if [[ "$1" == "--help" ]] || [[ "$1" == "-h" ]] ; then
        echo "rcd : 'repos-cd' is a shell function to cd to repos
by their names in ~/.config/repos.yml.  This function
has AUTOCOMPLETE based on the repos listed in ~/.config/repos.yml

Usage:

    rcd REPO-NAME

See 'man rcd' for more information."
        return
    fi

    local repo_name=${1%%/*}
    local repo_subdir
    if [[ ${1} == */* ]] ; then
        local repo_subdir=${1#*/}
    fi
    local repo_dir
    if ! repo_dir=$(repos -get-dir ${repo_name} 2>/dev/null) ; then
        echo "ERROR: No repo '$1' in ~/.config/repos.yml" >&2
        return 1
    fi

    local dir
    dir=${repo_dir}/${repo_subdir}
    printf "\033[33mcd $dir\033[0m\n"
    cd $dir

}

__complete_rcd(){
	COMPREPLY=()
	# We use the current word to filter out suggestions
	local cur="${COMP_WORDS[COMP_CWORD]}"
	# Compgen: takes the list of candidates and selects those matching ${cur}.
	# Once COMPREPLY is set, the shell does the rest.

    local repo_name=${cur%%/*}
    local repo_subdir=${cur#*/}


    if [[ "${cur}" == */* ]] ; then
        if ! repo_dir=$(repos -get-dir ${repo_name} 2>/dev/null) ; then
            return
        fi
        compopt -o filenames
        local i=0
        # echo "\${repo_dir}/\${repo_subdir}=${repo_dir}/${repo_subdir}" >> ~/.log.txt
        for full_path in $(compgen -d -- ${repo_dir}/${repo_subdir}) ; do
            if [[ $(basename ${full_path}) == .* ]] ; then
                continue
            fi
            # echo "full_path=${full_path}" >> ~/.log.txt
            relative_path="${full_path##${repo_dir}}"
            # echo "relative_path=${relative_path}" >> ~/.log.txt
            COMPREPLY[i++]="${repo_name}${relative_path}"
            last_full_path=${full_path}
        done

    else
        COMPREPLY=( $(compgen -W "$(repos -list-names 2>/dev/null)" -- ${cur}))
    fi

    if ((${#COMPREPLY[@]} == 1)) ; then
        if ! [[ $(find ${last_full_path} -maxdepth 1 -type d) == ${last_full_path} ]] ; then
            compopt -o nospace
            COMPREPLY[0]+=/;
        fi
    fi;
}
complete -o default -F __complete_rcd rcd

if ! [ -e ~/.config/repos.yml ] ; then
    printf "\033[33mrepos_completion.bash : WARNING: No '~/.config/repos.yml' file found.\n" >&2
    printf "Consider doing \n" >&2
    printf "    'repos -generate-config > ~/.config/repos.yml'\n" >&2
    printf "from a directory that CONTAINS git repos\033[0m\n" >&2
fi
